<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · NearOptimalAlternatives.jl</title><meta name="title" content="Reference · NearOptimalAlternatives.jl"/><meta property="og:title" content="Reference · NearOptimalAlternatives.jl"/><meta property="twitter:title" content="Reference · NearOptimalAlternatives.jl"/><meta name="description" content="Documentation for NearOptimalAlternatives.jl."/><meta property="og:description" content="Documentation for NearOptimalAlternatives.jl."/><meta property="twitter:description" content="Documentation for NearOptimalAlternatives.jl."/><meta property="og:url" content="https://TulipaEnergy.github.io/NearOptimalAlternatives.jl/95-reference/"/><meta property="twitter:url" content="https://TulipaEnergy.github.io/NearOptimalAlternatives.jl/95-reference/"/><link rel="canonical" href="https://TulipaEnergy.github.io/NearOptimalAlternatives.jl/95-reference/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NearOptimalAlternatives.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Welcome</a></li><li><a class="tocitem" href="../10-how-to-use/">How to use</a></li><li><a class="tocitem" href="../20-tutorials/">Tutorials</a></li><li><a class="tocitem" href="../30-concepts/">Concepts</a></li><li><a class="tocitem" href="../90-contributing/">Contributing guidelines</a></li><li><a class="tocitem" href="../91-developer/">Developer documentation</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/main/docs/src/95-reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="reference"><a class="docs-heading-anchor" href="#reference">Reference</a><a id="reference-1"></a><a class="docs-heading-anchor-permalink" href="#reference" title="Permalink"></a></h1><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#reference">Reference</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#NearOptimalAlternatives.METHOD_DISPATCH_UPDATE"><code>NearOptimalAlternatives.METHOD_DISPATCH_UPDATE</code></a></li><li><a href="#NearOptimalAlternatives.AlternativeSolutions"><code>NearOptimalAlternatives.AlternativeSolutions</code></a></li><li><a href="#NearOptimalAlternatives.MetaheuristicProblem"><code>NearOptimalAlternatives.MetaheuristicProblem</code></a></li><li><a href="#NearOptimalAlternatives.PSOGA-Tuple{}"><code>NearOptimalAlternatives.PSOGA</code></a></li><li><a href="#NearOptimalAlternatives.PSOGA"><code>NearOptimalAlternatives.PSOGA</code></a></li><li><a href="#Metaheuristics.final_stage!-Tuple{Any, NearOptimalAlternatives.PSOGA, Metaheuristics.AbstractProblem, Metaheuristics.Information, Metaheuristics.Options, Vararg{Any}}"><code>Metaheuristics.final_stage!</code></a></li><li><a href="#Metaheuristics.initialize!-Tuple{Any, NearOptimalAlternatives.PSOGA, Any, Any, Any, Vararg{Any}}"><code>Metaheuristics.initialize!</code></a></li><li><a href="#Metaheuristics.update_state!-Tuple{Any, NearOptimalAlternatives.PSOGA, Metaheuristics.AbstractProblem, Metaheuristics.Information, Metaheuristics.Options, Vararg{Any}}"><code>Metaheuristics.update_state!</code></a></li><li><a href="#NearOptimalAlternatives.DWV_initial!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}, Vector{JuMP.VariableRef}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><code>NearOptimalAlternatives.DWV_initial!</code></a></li><li><a href="#NearOptimalAlternatives.DWV_update!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><code>NearOptimalAlternatives.DWV_update!</code></a></li><li><a href="#NearOptimalAlternatives.Dist_initial!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}, Vector{JuMP.VariableRef}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><code>NearOptimalAlternatives.Dist_initial!</code></a></li><li><a href="#NearOptimalAlternatives.Dist_update!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><code>NearOptimalAlternatives.Dist_update!</code></a></li><li><a href="#NearOptimalAlternatives.HSJ_initial!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}, Vector{JuMP.VariableRef}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><code>NearOptimalAlternatives.HSJ_initial!</code></a></li><li><a href="#NearOptimalAlternatives.HSJ_update!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><code>NearOptimalAlternatives.HSJ_update!</code></a></li><li><a href="#NearOptimalAlternatives.Min_Max_Variables_initial!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}, Vector{JuMP.VariableRef}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><code>NearOptimalAlternatives.Min_Max_Variables_initial!</code></a></li><li><a href="#NearOptimalAlternatives.Min_Max_Variables_update!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><code>NearOptimalAlternatives.Min_Max_Variables_update!</code></a></li><li><a href="#NearOptimalAlternatives.Random_Vector_initial!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}, Vector{JuMP.VariableRef}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><code>NearOptimalAlternatives.Random_Vector_initial!</code></a></li><li><a href="#NearOptimalAlternatives.Random_Vector_update!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><code>NearOptimalAlternatives.Random_Vector_update!</code></a></li><li><a href="#NearOptimalAlternatives.Spores_initial!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}, Vector{JuMP.VariableRef}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><code>NearOptimalAlternatives.Spores_initial!</code></a></li><li><a href="#NearOptimalAlternatives.Spores_update!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><code>NearOptimalAlternatives.Spores_update!</code></a></li><li><a href="#NearOptimalAlternatives.add_solution!-Tuple{NearOptimalAlternatives.MetaheuristicProblem, Metaheuristics.State, Distances.SemiMetric}"><code>NearOptimalAlternatives.add_solution!</code></a></li><li><a href="#NearOptimalAlternatives.create_alternative_generating_problem-Tuple{JuMP.Model, Metaheuristics.Algorithm, OrderedCollections.OrderedDict{JuMP.VariableRef, Float64}, Float64, Distances.SemiMetric, Dict{MathOptInterface.VariableIndex, Float64}}"><code>NearOptimalAlternatives.create_alternative_generating_problem</code></a></li><li><a href="#NearOptimalAlternatives.create_alternative_generating_problem!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, Float64, Vector{JuMP.VariableRef}, AbstractArray{T, N}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><code>NearOptimalAlternatives.create_alternative_generating_problem!</code></a></li><li><a href="#NearOptimalAlternatives.create_objective-Tuple{JuMP.Model, OrderedCollections.OrderedDict{JuMP.VariableRef, Float64}, Float64, Distances.SemiMetric, Dict{Int64, Int64}, Dict{MathOptInterface.VariableIndex, Float64}}"><code>NearOptimalAlternatives.create_objective</code></a></li><li><a href="#NearOptimalAlternatives.extract_bounds-Tuple{JuMP.Model, Dict{Int64, Int64}}"><code>NearOptimalAlternatives.extract_bounds</code></a></li><li><a href="#NearOptimalAlternatives.extract_constraint-Tuple{MathOptInterface.ScalarAffineFunction, Vector{Float64}, Dict{Int64, Int64}, Dict{MathOptInterface.VariableIndex, Float64}}"><code>NearOptimalAlternatives.extract_constraint</code></a></li><li><a href="#NearOptimalAlternatives.extract_objective-Tuple{JuMP.AffExpr, Vector{Float64}, Dict{Int64, Int64}, Dict{MathOptInterface.VariableIndex, Float64}}"><code>NearOptimalAlternatives.extract_objective</code></a></li><li><a href="#NearOptimalAlternatives.generate_alternatives_metaheuristics-Tuple{JuMP.Model, Float64, Int64, Metaheuristics.Algorithm}"><code>NearOptimalAlternatives.generate_alternatives_metaheuristics</code></a></li><li><a href="#NearOptimalAlternatives.generate_alternatives_optimization!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, Float64, AbstractArray{T, N}, Int64}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><code>NearOptimalAlternatives.generate_alternatives_optimization!</code></a></li><li><a href="#NearOptimalAlternatives.is_better_psoga-Union{Tuple{T}, Tuple{T, T, Matrix{Float64}, Int64, Bool}} where T&lt;:Metaheuristics.xFgh_solution"><code>NearOptimalAlternatives.is_better_psoga</code></a></li><li><a href="#NearOptimalAlternatives.run_alternative_generating_problem!-Tuple{NearOptimalAlternatives.MetaheuristicProblem}"><code>NearOptimalAlternatives.run_alternative_generating_problem!</code></a></li><li><a href="#NearOptimalAlternatives.update_objective_function!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><code>NearOptimalAlternatives.update_objective_function!</code></a></li><li><a href="#NearOptimalAlternatives.update_solutions!-Tuple{NearOptimalAlternatives.AlternativeSolutions, Metaheuristics.State, Vector{Any}, OrderedCollections.OrderedDict{JuMP.VariableRef, Float64}, Dict{MathOptInterface.VariableIndex, Float64}, JuMP.Model}"><code>NearOptimalAlternatives.update_solutions!</code></a></li><li><a href="#NearOptimalAlternatives.update_solutions!-Tuple{NearOptimalAlternatives.AlternativeSolutions, JuMP.Model}"><code>NearOptimalAlternatives.update_solutions!</code></a></li><li><a href="#NearOptimalAlternatives.update_solutions!-Tuple{NearOptimalAlternatives.AlternativeSolutions, Metaheuristics.State, OrderedCollections.OrderedDict{JuMP.VariableRef, Float64}, Dict{MathOptInterface.VariableIndex, Float64}, JuMP.Model}"><code>NearOptimalAlternatives.update_solutions!</code></a></li></ul><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.METHOD_DISPATCH_UPDATE"><a class="docstring-binding" href="#NearOptimalAlternatives.METHOD_DISPATCH_UPDATE"><code>NearOptimalAlternatives.METHOD_DISPATCH_UPDATE</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p>const METHOD<em>DISPATCH shows the mapping of method symbols to their corresponding update functions for the modelling-for-generating-alternatives problem. It is used to dynamically select the appropriate function based on the method specified in the `create</em>alternative<em>generating</em>problem!` function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/alternative-optimization.jl#L3-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.AlternativeSolutions"><a class="docstring-binding" href="#NearOptimalAlternatives.AlternativeSolutions"><code>NearOptimalAlternatives.AlternativeSolutions</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Structure holding the solutions for the near-optimal alternatives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/results.jl#L1-L3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.MetaheuristicProblem"><a class="docstring-binding" href="#NearOptimalAlternatives.MetaheuristicProblem"><code>NearOptimalAlternatives.MetaheuristicProblem</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Structure representing a problem that can be solved by Metaheuristics.jl and the algorithm to solve it.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/alternative-metaheuristics.jl#L1-L3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.PSOGA"><a class="docstring-binding" href="#NearOptimalAlternatives.PSOGA"><code>NearOptimalAlternatives.PSOGA</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Structure holding all parameters for PSOGA (Particle Swarm optimization for Generating Alternatives).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/algorithms/PSOGA/PSOGA.jl#L8-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.PSOGA-Tuple{}"><a class="docstring-binding" href="#NearOptimalAlternatives.PSOGA-Tuple{}"><code>NearOptimalAlternatives.PSOGA</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PSOGA(;
    N = 100,
    N_solutions = 1,
    C1 = 2.0,
    C2 = 2.0,
    ω = 0.8,
    v = Float64[],
    flock == Metaheuristics.xf_indiv[],
    subBest = Metaheuristics.xf_indiv[],
    information = Information(),
    options = Options(),
)</code></pre><p>Construct a PSOGA Metaheuristic algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>N</code>: total population size</li><li><code>N_solutions::Int</code>: number of solutions sought. This is the same as the number of subpopulations searching for a solution.</li><li><code>C1::Float64</code>: cognitive parameter. Used to compute velocity based on own best solution.</li><li>`C2::Float64: social parameter. Used to compute velocity based on best solution in subpopulation.</li><li><code>ω::Float64</code>: inertia parameter. Used to compute velocity to ensure not too large changes.</li><li><code>v::Array{Float64}</code>: array of velocities per individual.</li><li><code>flock::Array</code>: array of all current positions of each of the individuals.</li><li><code>subBest::Array</code>: array of best solutions per subpopulation.</li><li><code>maximise_total::Bool</code>: if true, we maximise the sum of distances between a point and all centroids of other subpopulations, else we maximise the minimum distance between a point and the centroids of other subpopulations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/algorithms/PSOGA/PSOGA.jl#L23-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Metaheuristics.final_stage!-Tuple{Any, NearOptimalAlternatives.PSOGA, Metaheuristics.AbstractProblem, Metaheuristics.Information, Metaheuristics.Options, Vararg{Any}}"><a class="docstring-binding" href="#Metaheuristics.final_stage!-Tuple{Any, NearOptimalAlternatives.PSOGA, Metaheuristics.AbstractProblem, Metaheuristics.Information, Metaheuristics.Options, Vararg{Any}}"><code>Metaheuristics.final_stage!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>final_stage(     status,     parameters::PSOGA,     problem,     information,     options,     args...;     kwargs...   )</p><p>Perform concluding operations after solving a problem using PSOGA. Called by main loop of Metaheuristics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/algorithms/PSOGA/PSOGA.jl#L237-L249">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Metaheuristics.initialize!-Tuple{Any, NearOptimalAlternatives.PSOGA, Any, Any, Any, Vararg{Any}}"><a class="docstring-binding" href="#Metaheuristics.initialize!-Tuple{Any, NearOptimalAlternatives.PSOGA, Any, Any, Any, Vararg{Any}}"><code>Metaheuristics.initialize!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>initialize!(     status,     parameters::PSOGA,     problem,     information,     options,     args...;     kwargs...   )</p><p>initialize all parameters used when solving a problem using PSOGA. Called by main loop of Metaheuristics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/algorithms/PSOGA/PSOGA.jl#L76-L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Metaheuristics.update_state!-Tuple{Any, NearOptimalAlternatives.PSOGA, Metaheuristics.AbstractProblem, Metaheuristics.Information, Metaheuristics.Options, Vararg{Any}}"><a class="docstring-binding" href="#Metaheuristics.update_state!-Tuple{Any, NearOptimalAlternatives.PSOGA, Metaheuristics.AbstractProblem, Metaheuristics.Information, Metaheuristics.Options, Vararg{Any}}"><code>Metaheuristics.update_state!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>update_state(     status,     parameters::PSOGA,     problem,     information,     options,     args...;     kwargs...   )</p><p>Perform one iteration of PSOGA. Called by main loop of Metaheuristics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/algorithms/PSOGA/PSOGA.jl#L143-L155">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.DWV_initial!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}, Vector{JuMP.VariableRef}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><a class="docstring-binding" href="#NearOptimalAlternatives.DWV_initial!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}, Vector{JuMP.VariableRef}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><code>NearOptimalAlternatives.DWV_initial!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">DWV_initial!(
    model::JuMP.Model,
    variables::AbstractArray{T,N},
    fixed_variables::Vector{VariableRef};
    weights::Vector{Float64} = zeros(length(variables)),
    metric::Distances.SemiMetric = SqEuclidean(),
    old_objective::AffExpr = JuMP.objective_function(model),
) where {T&lt;:Union{VariableRef,AffExpr},N}</code></pre><p>Initialize the objective of a JuMP model using the Directionally Weighted Variables method to generate alternative solutions. This function sets a new objective that minimizes the weighted sum of the decision variables, where weights are uniformly chosen between -1 and 1, based on the original objective function. Fixed variables are locked at their optimal values.</p><p><strong>Arguments</strong></p><ul><li><code>model::JuMP.Model</code>: a solved JuMP model whose objective is to be redefined for alternative generation.</li><li><code>variables::AbstractArray{T,N}</code>: the variables involved in the objective, typically a vector or matrix of <code>VariableRef</code>s or <code>AffExpr</code>s.</li><li><code>fixed_variables::Vector{VariableRef}</code>: variables to be fixed at their current values to avoid changes in alternatives.</li><li><code>weights::Vector{Float64}</code>: optional vector of weights for each variable; will be internally overwritten based on variable values.</li><li><code>metric::Distances.SemiMetric</code>: unused in this method (included for consistency with other alternative generation methods).</li><li><code>old_objective::AffExpr</code>: the original objective function of the model, used to determine variable weights.</li></ul><p><strong>Behavior</strong></p><ul><li>Variables are randomly minimized or maximized, based on the original objective function.</li><li>Fixed variables are frozen at their optimal values using <code>fix(...)</code>.</li><li>The objective is set to minimize the weighted sum of the variables, encouraging sparsity or deviation from the original.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/MGA-Methods/Directionally-Weighted-Variables.jl#L3-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.DWV_update!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><a class="docstring-binding" href="#NearOptimalAlternatives.DWV_update!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><code>NearOptimalAlternatives.DWV_update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">DWV_update!(
    model::JuMP.Model,
    variables::AbstractArray{T,N},
    weights::Vector{Float64}
) where {T&lt;:Union{VariableRef,AffExpr},N}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/MGA-Methods/Directionally-Weighted-Variables.jl#L57-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.Dist_initial!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}, Vector{JuMP.VariableRef}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><a class="docstring-binding" href="#NearOptimalAlternatives.Dist_initial!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}, Vector{JuMP.VariableRef}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><code>NearOptimalAlternatives.Dist_initial!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Dist_initial!(
    model::JuMP.Model,
    variables::AbstractArray{T,N},
    fixed_variables::Vector{VariableRef};
    weights::Vector{Float64} = zeros(length(variables)),
    metric::Distances.SemiMetric = SqEuclidean(),
) where {T&lt;:Union{VariableRef,AffExpr},N}</code></pre><p>Initialize a JuMP model&#39;s objective to maximize the distance between the current solution and a reference solution, based on a specified metric.</p><p>This function is typically used in the context of generating diverse solutions (alternatives) to an optimization problem by first defining a distance-based objective that measures how different a new solution is from an existing (optimal) one.</p><p><strong>Arguments</strong></p><ul><li><code>model::JuMP.Model</code>: a JuMP model that has been previously solved.</li><li><code>variables::AbstractArray{T,N}</code>: the variables of the model to consider in the distance computation.</li><li><code>fixed_variables::Vector{VariableRef}</code>: a subset of all variables of <code>model</code> that are not allowed to be changed when seeking for alternatives.</li><li><code>weights::Vector{Float64}</code>: optional weights to influence the distance calculation (currently not used directly but reserved for extensions).</li><li><code>metric::Distances.SemiMetric</code>: the distance metric used to compute dissimilarity (default is squared Euclidean distance).</li></ul><p><strong>Behavior</strong></p><ul><li>Extracts the current solution values of <code>variables</code>.</li><li>Sets the model&#39;s objective to maximize the distance between the current variable values and the solution.</li><li>Changes the model&#39;s objective sense to <code>Max</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/MGA-Methods/Max-Distance.jl#L3-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.Dist_update!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><a class="docstring-binding" href="#NearOptimalAlternatives.Dist_update!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><code>NearOptimalAlternatives.Dist_update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Dist_update!(
    model::JuMP.Model,
    variables::AbstractArray{T,N};
    weights::Vector{Float64} = zeros(length(variables)),
    metric::Distances.SemiMetric = Cityblock(),
) where {T&lt;:Union{VariableRef,AffExpr},N}</code></pre><p>Update a JuMP model&#39;s objective function to include an additional distance term for generating multiple diverse alternatives (as in Modeling to Generate Alternatives).</p><p>This function builds upon a previously defined objective by incrementally adding a distance term between the current solution and a new reference solution. It is typically used after <code>Dist_initial!</code> or a prior call to <code>MGA_Dist_update!</code>.</p><p><strong>Arguments</strong></p><ul><li><code>model::JuMP.Model</code>: the JuMP model being updated to generate further alternatives.</li><li><code>variables::AbstractArray{T,N}</code>: the variables to consider in the distance computation.</li><li><code>weights::Vector{Float64}</code>: optional weights for the distance metric (currently not directly used).</li><li><code>metric::Distances.SemiMetric</code>: the distance metric used to compute dissimilarity (default is Cityblock distance).</li></ul><p><strong>Behavior</strong></p><ul><li>Evaluates the current objective function to retrieve the cumulative distance so far.</li><li>Computes the distance between the current variable values and their previous optimal values.</li><li>Updates the objective function to maximize the sum of the cumulative and new distances.</li><li>Resets the model&#39;s objective sense to <code>Max</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/MGA-Methods/Max-Distance.jl#L48-L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.HSJ_initial!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}, Vector{JuMP.VariableRef}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><a class="docstring-binding" href="#NearOptimalAlternatives.HSJ_initial!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}, Vector{JuMP.VariableRef}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><code>NearOptimalAlternatives.HSJ_initial!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">HSJ_initial!(
    model::JuMP.Model,
    variables::AbstractArray{T,N},
    fixed_variables::Vector{VariableRef};
    weights::Vector{Float64} = zeros(length(variables)),
    metric::Distances.SemiMetric = SqEuclidean(),
) where {T&lt;:Union{VariableRef,AffExpr}, N}</code></pre><p>Initialize the objective of a JuMP model using the HSJ (Hop-Skip-Jump) method to generate alternative solutions.</p><p>This function sets a new objective that minimizes the weighted sum of the decision variables, where weights are based on the sign (non-zero value) of the original optimal solution. Fixed variables are locked at their optimal values.</p><p><strong>Arguments</strong></p><ul><li><code>model::JuMP.Model</code>: a solved JuMP model whose objective is to be redefined for alternative generation.</li><li><code>variables::AbstractArray{T,N}</code>: the variables involved in the objective, typically a vector or matrix of <code>VariableRef</code>s or <code>AffExpr</code>s.</li><li><code>fixed_variables::Vector{VariableRef}</code>: variables to be fixed at their current values to avoid changes in alternatives.</li><li><code>weights::Vector{Float64}</code>: optional vector of weights for each variable; will be internally overwritten based on variable values.</li><li><code>metric::Distances.SemiMetric</code>: unused in this method (included for consistency with other alternative generation methods).</li></ul><p><strong>Behavior</strong></p><ul><li>Variables that are zero in the original solution receive weight 0; others receive weight 1.</li><li>Fixed variables are frozen at their optimal values using <code>fix(...)</code>.</li><li>The objective is set to minimize the weighted sum of the variables, encouraging sparsity or deviation from the original.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/MGA-Methods/HSJ.jl#L4-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.HSJ_update!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><a class="docstring-binding" href="#NearOptimalAlternatives.HSJ_update!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><code>NearOptimalAlternatives.HSJ_update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">HSJ_update!(
    model::JuMP.Model,
    variables::AbstractArray{T,N};
    weights::Vector{Float64} = zeros(length(variables)),
    metric::Distances.SemiMetric = SqEuclidean(),
) where {T&lt;:Union{VariableRef,AffExpr}, N}</code></pre><p>Update the objective of a JuMP model using the HSJ method to generate the next alternative solution.</p><p>This function redefines the objective based on the current optimal solution of the model, using weights determined by the sign of each variable&#39;s value (non-zero implies weight 1).</p><p><strong>Arguments</strong></p><ul><li><code>model::JuMP.Model</code>: the JuMP model to be updated.</li><li><code>variables::AbstractArray{T,N}</code>: the decision variables involved in the updated objective.</li><li><code>weights::Vector{Float64}</code>: optional vector of weights; will be overwritten based on current variable values.</li><li><code>metric::Distances.SemiMetric</code>: unused in this method (included for interface consistency).</li></ul><p><strong>Behavior</strong></p><ul><li>Variables with a zero value receive weight 0; all others receive weight 1.</li><li>A new objective is set: minimize the weighted sum of the variables.</li><li>This function does not re-fix any variables; it is typically called iteratively after <code>HSJ_initial!</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/MGA-Methods/HSJ.jl#L54-L76">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.Min_Max_Variables_initial!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}, Vector{JuMP.VariableRef}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><a class="docstring-binding" href="#NearOptimalAlternatives.Min_Max_Variables_initial!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}, Vector{JuMP.VariableRef}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><code>NearOptimalAlternatives.Min_Max_Variables_initial!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Min_Max_Variables_initial!(
    model::JuMP.Model,
    variables::AbstractArray{T,N},
    fixed_variables::Vector{VariableRef};
    weights::Vector{Float64} = zeros(length(variables)),
    metric::Distances.SemiMetric = SqEuclidean(),
) where {T&lt;:Union{VariableRef,AffExpr}, N}</code></pre><p>Initialize the objective of a JuMP model using the Min/Max Variables method to generate alternative solutions. This function sets a new objective that minimizes the weighted sum of the decision variables, where weights are randomized between -1, 0 and 1. Fixed variables are locked at their optimal values.</p><p><strong>Arguments</strong></p><ul><li><code>model::JuMP.Model</code>: a solved JuMP model whose objective is to be redefined for alternative generation.</li><li><code>variables::AbstractArray{T,N}</code>: the variables involved in the objective, typically a vector or matrix of <code>VariableRef</code>s or <code>AffExpr</code>s.</li><li><code>fixed_variables::Vector{VariableRef}</code>: variables to be fixed at their current values to avoid changes in alternatives.</li><li><code>weights::Vector{Float64}</code>: optional vector of weights for each variable; will be internally overwritten based on variable values.</li><li><code>metric::Distances.SemiMetric</code>: unused in this method (included for consistency with other alternative generation methods).</li></ul><p><strong>Behavior</strong></p><ul><li>Variables are randomly minimized or maximized.</li><li>Fixed variables are frozen at their optimal values using <code>fix(...)</code>.</li><li>The objective is set to minimize the weighted sum of the variables, encouraging sparsity or deviation from the original.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/MGA-Methods/Min-Max-Variables.jl#L4-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.Min_Max_Variables_update!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><a class="docstring-binding" href="#NearOptimalAlternatives.Min_Max_Variables_update!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><code>NearOptimalAlternatives.Min_Max_Variables_update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Min_Max_Variables_update!(
    model::JuMP.Model,
    variables::AbstractArray{T,N};
    weights::Vector{Float64} = zeros(length(variables)),
    metric::Distances.SemiMetric = SqEuclidean(),
) where {T&lt;:Union{VariableRef,AffExpr}, N}</code></pre><p>Update the objective of a JuMP model using the Min/Max Variables method to generate the next alternative solution. Update the weights randomly between -1, 0 and 1.</p><p><strong>Arguments</strong></p><ul><li><code>model::JuMP.Model</code>: the JuMP model to be updated.</li><li><code>variables::AbstractArray{T,N}</code>: the decision variables involved in the updated objective.</li><li><code>weights::Vector{Float64}</code>: optional vector of weights; will be overwritten based on current variable values.</li><li><code>metric::Distances.SemiMetric</code>: unused in this method (included for interface consistency).</li></ul><p><strong>Behavior</strong></p><ul><li>Variables are randomly minimized or maximized.</li><li>A new objective is set: minimize the weighted sum of the variables.</li><li>This function does not re-fix any variables; it is typically called iteratively after <code>Min_Max_Variables_initial!</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/MGA-Methods/Min-Max-Variables.jl#L46-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.Random_Vector_initial!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}, Vector{JuMP.VariableRef}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><a class="docstring-binding" href="#NearOptimalAlternatives.Random_Vector_initial!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}, Vector{JuMP.VariableRef}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><code>NearOptimalAlternatives.Random_Vector_initial!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Random_Vector_initial!(
    model::JuMP.Model,
    variables::AbstractArray{T,N},
    fixed_variables::Vector{VariableRef};
    weights::Vector{Float64} = zeros(length(variables)),
    metric::Distances.SemiMetric = SqEuclidean(),
) where {T&lt;:Union{VariableRef,AffExpr}, N}</code></pre><p>Initialize the objective of a JuMP model using the Min/Max Variables method to generate alternative solutions. This function sets a new objective that minimizes the weighted sum of the decision variables, where weights are uniformly chosen between -1 and 1. Fixed variables are locked at their optimal values.</p><p><strong>Arguments</strong></p><ul><li><code>model::JuMP.Model</code>: a solved JuMP model whose objective is to be redefined for alternative generation.</li><li><code>variables::AbstractArray{T,N}</code>: the variables involved in the objective, typically a vector or matrix of <code>VariableRef</code>s or <code>AffExpr</code>s.</li><li><code>fixed_variables::Vector{VariableRef}</code>: variables to be fixed at their current values to avoid changes in alternatives.</li><li><code>weights::Vector{Float64}</code>: optional vector of weights for each variable; will be internally overwritten based on variable values.</li><li><code>metric::Distances.SemiMetric</code>: unused in this method (included for consistency with other alternative generation methods).</li></ul><p><strong>Behavior</strong></p><ul><li>Variables are randomly minimized or maximized.</li><li>Fixed variables are frozen at their optimal values using <code>fix(...)</code>.</li><li>The objective is set to minimize the weighted sum of the variables, encouraging sparsity or deviation from the original.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/MGA-Methods/Random-Vector.jl#L4-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.Random_Vector_update!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><a class="docstring-binding" href="#NearOptimalAlternatives.Random_Vector_update!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><code>NearOptimalAlternatives.Random_Vector_update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Random_Vector_update!(
    model::JuMP.Model,
    variables::AbstractArray{T,N};
    weights::Vector{Float64} = zeros(length(variables)),
    metric::Distances.SemiMetric = SqEuclidean(),
) where {T&lt;:Union{VariableRef,AffExpr}, N}</code></pre><p>Update the objective of a JuMP model using the Min/Max Variables method to generate the next alternative solution. Update the weights uniformly chosen between -1 and 1.</p><p><strong>Arguments</strong></p><ul><li><code>model::JuMP.Model</code>: the JuMP model to be updated.</li><li><code>variables::AbstractArray{T,N}</code>: the decision variables involved in the updated objective.</li><li><code>weights::Vector{Float64}</code>: optional vector of weights; will be overwritten based on current variable values.</li><li><code>metric::Distances.SemiMetric</code>: unused in this method (included for interface consistency).</li></ul><p><strong>Behavior</strong></p><ul><li>Variables are randomly minimized or maximized.</li><li>A new objective is set: minimize the weighted sum of the variables.</li><li>This function does not re-fix any variables; it is typically called iteratively after <code>Random_Vector_initial!</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/MGA-Methods/Random-Vector.jl#L46-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.Spores_initial!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}, Vector{JuMP.VariableRef}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><a class="docstring-binding" href="#NearOptimalAlternatives.Spores_initial!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}, Vector{JuMP.VariableRef}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><code>NearOptimalAlternatives.Spores_initial!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Spores_initial!(
    model::JuMP.Model,
    variables::AbstractArray{T,N},
    fixed_variables::Vector{VariableRef};
    weights::Vector{Float64} = zeros(length(variables)),
    metric::Distances.SemiMetric = SqEuclidean(),
) where {T&lt;:Union{VariableRef,AffExpr}, N}</code></pre><p>Initialize the objective of a JuMP model using the Spores method to generate alternative solutions. This function sets a new objective that minimizes the weighted sum of the decision variables, where weights are based on the  variable value of the original optimal solution. Fixed variables are locked at their optimal values. For this method to work the upper bound of the variables must be set.</p><p><strong>Arguments</strong></p><ul><li><code>model::JuMP.Model</code>: a solved JuMP model whose objective is to be redefined for alternative generation.</li><li><code>variables::AbstractArray{T,N}</code>: the variables involved in the objective, typically a vector or matrix of <code>VariableRef</code>s or <code>AffExpr</code>s.</li><li><code>fixed_variables::Vector{VariableRef}</code>: variables to be fixed at their current values to avoid changes in alternatives.</li><li><code>weights::Vector{Float64}</code>: optional vector of weights for each variable; will be internally overwritten based on variable values.</li><li><code>metric::Distances.SemiMetric</code>: unused in this method (included for consistency with other alternative generation methods).</li></ul><p><strong>Behavior</strong></p><ul><li>Variables are updated based on the potential value that they could have had.</li><li>Fixed variables are frozen at their optimal values using <code>fix(...)</code>.</li><li>The objective is set to minimize the weighted sum of the variables, encouraging sparsity or deviation from the original.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/MGA-Methods/Spores.jl#L4-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.Spores_update!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><a class="docstring-binding" href="#NearOptimalAlternatives.Spores_update!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><code>NearOptimalAlternatives.Spores_update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Spores_update!(
    model::JuMP.Model,
    variables::AbstractArray{T,N};
    weights::Vector{Float64} = zeros(length(variables)),
    metric::Distances.SemiMetric = SqEuclidean(),
) where {T&lt;:Union{VariableRef,AffExpr}, N}</code></pre><p>Update the objective of a JuMP model using the Spores method to generate the next alternative solution. This function redefines the objective based on the current optimal solution of the model, updating the weights with respect to the current variable values.</p><p><strong>Arguments</strong></p><ul><li><code>model::JuMP.Model</code>: the JuMP model to be updated.</li><li><code>variables::AbstractArray{T,N}</code>: the decision variables involved in the updated objective.</li><li><code>weights::Vector{Float64}</code>: optional vector of weights; will be overwritten based on current variable values.</li><li><code>metric::Distances.SemiMetric</code>: unused in this method (included for interface consistency).</li></ul><p><strong>Behavior</strong></p><ul><li>Variables with are updated based on the previously optimal solution.</li><li>A new objective is set: minimize the weighted sum of the variables.</li><li>This function does not re-fix any variables; it is typically called iteratively after <code>Spores_initial!</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/MGA-Methods/Spores.jl#L47-L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.add_solution!-Tuple{NearOptimalAlternatives.MetaheuristicProblem, Metaheuristics.State, Distances.SemiMetric}"><a class="docstring-binding" href="#NearOptimalAlternatives.add_solution!-Tuple{NearOptimalAlternatives.MetaheuristicProblem, Metaheuristics.State, Distances.SemiMetric}"><code>NearOptimalAlternatives.add_solution!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_solution!(
    problem::MetaheuristicProblem,
    result::Metaheuristics.State,
    metric::Distances.SemiMetric
)</code></pre><p>Modify a Metaheuristic problem representing the alternative generating problem for the original LP using a newly found alternative solution. This function can be used when one wants to iteratively run a metaheuristic to find alternative solutions one by one.</p><p><strong>Arguments:</strong></p><ul><li><code>problem::MetaheuristicProblem</code>: problem to be modified by adding a solution.</li><li><code>result::Metaheuristics.State</code>: result containing the optimal solution to add to the objective function.</li><li><code>metric::Distances.SemiMetric</code>: metric used to evaluate distance between alternatives.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/alternative-metaheuristics.jl#L302-L315">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.create_alternative_generating_problem!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, Float64, Vector{JuMP.VariableRef}, AbstractArray{T, N}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><a class="docstring-binding" href="#NearOptimalAlternatives.create_alternative_generating_problem!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, Float64, Vector{JuMP.VariableRef}, AbstractArray{T, N}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><code>NearOptimalAlternatives.create_alternative_generating_problem!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_alternative_generating_problem!(
  model::JuMP.Model,
  optimality_gap::Float64,
  fixed_variables::Vector{VariableRef},
  variables::AbstractArray{T,N},
  weights::Vector{Float64};
  method::Symbol = :HSJ,
  metric::Distances.SemiMetric = SqEuclidean(),
) where {T&lt;:Union{VariableRef,AffExpr},N}</code></pre><p>Transform a JuMP model into a model solving its corresponding modelling-for-generating-alternatives problem.</p><p><strong>Arguments</strong></p><ul><li><code>model::JuMP.Model</code>: a solved JuMP model for which alternatives are generated.</li><li><code>optimality_gap::Float64</code>: the maximum percentage deviation (&gt;= 0) an alternative may have compared to the optimal solution.</li><li><code>fixed_variables::Vector{VariableRef}=[]</code>: a subset of all variables of <code>model</code> that are not allowed to be changed when seeking for alternatives.</li><li><code>variables::AbstractArray{T,N}</code>: the variables of <code>model</code> for which are considered when generating alternatives.</li><li><code>weights::Vector{Float64}</code>: a vector of weights used to update the objective function.</li><li><code>method::Symbol = :HSJ</code>: the method used to model the problem for generating alternatives.</li><li><code>metric::Distances.SemiMetric = SqEuclidean()</code>: the metric used to maximise the difference between alternatives and the optimal solution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/alternative-optimization.jl#L26-L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.create_alternative_generating_problem-Tuple{JuMP.Model, Metaheuristics.Algorithm, OrderedCollections.OrderedDict{JuMP.VariableRef, Float64}, Float64, Distances.SemiMetric, Dict{MathOptInterface.VariableIndex, Float64}}"><a class="docstring-binding" href="#NearOptimalAlternatives.create_alternative_generating_problem-Tuple{JuMP.Model, Metaheuristics.Algorithm, OrderedCollections.OrderedDict{JuMP.VariableRef, Float64}, Float64, Distances.SemiMetric, Dict{MathOptInterface.VariableIndex, Float64}}"><code>NearOptimalAlternatives.create_alternative_generating_problem</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">problem = create_alternative_generating_problem(
    model::JuMP.Model,
    algorithm::Metaheuristics.Algorithm,
    initial_solution::OrderedDict{VariableRef, Float64},
    optimality_gap::Float64,
    metric::Distances.SemiMetric,
    fixed_variables::Dict{VariableRef, Float64}
)</code></pre><p>Create the Metaheuristic problem representing the alternative generating problem for the original LP.</p><p><strong>Arguments:</strong></p><ul><li><code>model::JuMP.Model</code>: JuMP model representing the original LP.</li><li><code>algorithm::Metaheuristics.Algorithm</code>: Metaheuristic algorithm to solve the alternative generating problem.</li><li><code>initial_solution::OrderedDict{VariableRef, Float64}</code>: (near-)optimal solution to <code>model</code>, for which alternatives are sought.</li><li><code>optimality_gap::Float64</code>: maximum gap in objective value between <code>initial_solution</code> and alternative solutions.</li><li><code>metric::Distances.SemiMetric</code>: distance metric used to compute distance between alternative solutions and <code>initial_solution</code>.</li><li><code>fixed_variables::Dict{MOI.VariableIndex, Float64}</code>: solution values for fixed variables of the original problem.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/alternative-metaheuristics.jl#L253-L272">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.create_objective-Tuple{JuMP.Model, OrderedCollections.OrderedDict{JuMP.VariableRef, Float64}, Float64, Distances.SemiMetric, Dict{Int64, Int64}, Dict{MathOptInterface.VariableIndex, Float64}}"><a class="docstring-binding" href="#NearOptimalAlternatives.create_objective-Tuple{JuMP.Model, OrderedCollections.OrderedDict{JuMP.VariableRef, Float64}, Float64, Distances.SemiMetric, Dict{Int64, Int64}, Dict{MathOptInterface.VariableIndex, Float64}}"><code>NearOptimalAlternatives.create_objective</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">objective = create_objective(
    model::JuMP.Model,
    solution::OrderedDict{JuMP.VariableRef, Float64},
    optimality_gap::Float64,
    metric::Distances.SemiMetric,
    index_map::Dict{Int64, Int64},
    fixed_variables::Dict{VariableRef, Float64}
)</code></pre><p>Create an objective function supported by Metaheuristics.jl for the alternative generating problem.</p><p><strong>Arguments</strong></p><ul><li><code>model::JuMP.Model</code>: solved JuMP model of the original lp problem.</li><li><code>solution::OrderedDict{JuMP.VariableRef, Float64}</code>: solution value of the original lp problem excluding fixed variables.</li><li><code>optimality_gap::Float64</code>: maximum difference between objective value of optimal solution and alternative solutions.</li><li><code>metric::Distances.SemiMetric</code>: distance metric used to measure distance between solutions.</li><li><code>index_map::Dict{Int64, Int64}</code>: dictionary mapping indices in the JuMP/MathOptInterface model to indices of <code>x</code>.</li><li><code>fixed_variables::Dict{VariableRef, Float64}</code>: dictionary containing the values of the fixed variables.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/alternative-metaheuristics.jl#L80-L99">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.extract_bounds-Tuple{JuMP.Model, Dict{Int64, Int64}}"><a class="docstring-binding" href="#NearOptimalAlternatives.extract_bounds-Tuple{JuMP.Model, Dict{Int64, Int64}}"><code>NearOptimalAlternatives.extract_bounds</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bounds = extract_bounds(
    model::JuMP.Model,
    index_map::Dict{Int64, Int64}
)</code></pre><p>Transform the bounds from a JuMP Model into a matrix of bounds readable by Metaheuristics.jl.</p><p><strong>Arguments</strong></p><ul><li><code>model::JuMP.Model</code>: solved JuMP model of the original lp problem.</li><li><code>index_map::Dict{Int64, Int64}</code>: dictionary mapping indices in the JuMP/MathOptInterface model to indices of <code>x</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/alternative-metaheuristics.jl#L206-L217">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.extract_constraint-Tuple{MathOptInterface.ScalarAffineFunction, Vector{Float64}, Dict{Int64, Int64}, Dict{MathOptInterface.VariableIndex, Float64}}"><a class="docstring-binding" href="#NearOptimalAlternatives.extract_constraint-Tuple{MathOptInterface.ScalarAffineFunction, Vector{Float64}, Dict{Int64, Int64}, Dict{MathOptInterface.VariableIndex, Float64}}"><code>NearOptimalAlternatives.extract_constraint</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">constraint = extract_constraint(
    constraint::MOI.ConstraintFunction,
    x::Vector{Float64},
    index_map::Dict{Int64, Int64},
    fixed_variables::Dict{MOI.VariableIndex, Float64}
)</code></pre><p>Convert a constraint from a MathOptInterface function into a julia function of x. Supports only ScalarAffineFunction and VariableIndex constraints.</p><p><strong>Arguments</strong></p><ul><li><code>constraint::MOI.ConstraintFunction</code>: constraint transform into a julia function.</li><li><code>x::Vector{Float64}</code>: a vector representing an individual in the metaheuristic population.</li><li><code>index_map::Dict{Int64, Int64}</code>: a dictionary mapping indices in the MathOptInterface model to indices of <code>x</code>.</li><li><code>fixed_variables::Dict{MOI.VariableIndex, Float64}: a dictionary containing the values of the fixed variables.</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/alternative-metaheuristics.jl#L10-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.extract_objective-Tuple{JuMP.AffExpr, Vector{Float64}, Dict{Int64, Int64}, Dict{MathOptInterface.VariableIndex, Float64}}"><a class="docstring-binding" href="#NearOptimalAlternatives.extract_objective-Tuple{JuMP.AffExpr, Vector{Float64}, Dict{Int64, Int64}, Dict{MathOptInterface.VariableIndex, Float64}}"><code>NearOptimalAlternatives.extract_objective</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">objective = extract_objective(
    objective::JuMP.AffExpr,
    x::Vector{Float64},
    index_map::Dict{Int64, Int64},
    fixed_variables::Dict{MOI.VariableIndex, Float64}
)</code></pre><p>Convert the objective from a MathOptInterface function into a julia function of x. Supports only linear single-objective functions.</p><p><strong>Arguments</strong></p><ul><li><code>objective::JuMP.AffExpr</code>: the objective function to transform into a julia function.</li><li><code>x::Vector{Float64}</code>: a vector representing an individual in the metaheuristic population.</li><li><code>index_map::Dict{Int64, Int64}</code>: a dictionary mapping indices in the MathOptInterface model to indices of <code>x</code>.</li><li><code>fixed_variables::Dict{MOI.VariableIndex, Float64}: a dictionary containing the values of the fixed variables.</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/alternative-metaheuristics.jl#L43-L58">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.generate_alternatives_metaheuristics-Tuple{JuMP.Model, Float64, Int64, Metaheuristics.Algorithm}"><a class="docstring-binding" href="#NearOptimalAlternatives.generate_alternatives_metaheuristics-Tuple{JuMP.Model, Float64, Int64, Metaheuristics.Algorithm}"><code>NearOptimalAlternatives.generate_alternatives_metaheuristics</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">result = generate_alternatives_metaheuristics(
  model::JuMP.Model,
  optimality_gap::Float64,
  n_alternatives::Int64,
  metaheuristic_algorithm::Metaheuristics.Algorithm;
  metric::Distances.Metric = SqEuclidean(),
  selected_variables::Vector{VariableRef} = []
)</code></pre><p>Generate <code>n_alternatives</code> solutions to <code>model</code> which are as distant from the optimum and each other, but with a maximum <code>optimality_gap</code>, using a metaheuristic algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>model::JuMP.Model</code>: a solved JuMP model for which alternatives are generated.</li><li><code>optimality_gap::Float64</code>: the maximum percentage deviation (&gt;=0) an alternative may have compared to the optimal solution.</li><li><code>n_alternatives</code>: the number of alternative solutions sought.</li><li><code>metaheuristic_algorithm::Metaheuristics.Algorithm</code>: algorithm used to search for alternative solutions.</li><li><code>metric::Distances.Metric=SqEuclidean()</code>: the metric used to maximise the difference between alternatives and the optimal solution.</li><li><code>fixed_variables::Vector{VariableRef}=[]</code>: a subset of all variables of <code>model</code> that are not allowed to be changed when seeking for alternatives.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/generate-alternatives.jl#L82-L101">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.generate_alternatives_optimization!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, Float64, AbstractArray{T, N}, Int64}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><a class="docstring-binding" href="#NearOptimalAlternatives.generate_alternatives_optimization!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, Float64, AbstractArray{T, N}, Int64}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><code>NearOptimalAlternatives.generate_alternatives_optimization!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>results = generate<em>alternatives</em>optimization!(   model::JuMP.Model,   optimality<em>gap::Float64,   variables::AbstractArray{T,N},   n</em>alternatives::Int64;   modeling<em>method::Symbol = :Max</em>Distance,   metric::Distances.SemiMetric = SqEuclidean(),   fixed<em>variables::Vector{VariableRef} = VariableRef[], ) where {T&lt;:Union{VariableRef,AffExpr},N} Generate `n</em>alternatives<code>solutions to</code>model<code>which are as distant from the optimum and each other, but with a maximum</code>optimality_gap`, using optimization.</p><p><strong>Arguments</strong></p><ul><li><code>model::JuMP.Model</code>: a solved JuMP model for which alternatives are generated.</li><li><code>optimality_gap::Float64</code>: the maximum percentage deviation (&gt;=0) an alternative may have compared to the optimal solution.</li><li>variables::AbstractArray{T,N}: the variables of <code>model</code> for which are considered when generating alternatives.</li><li><code>n_alternatives</code>: the number of alternative solutions sought.</li><li><code>modeling_method::Symbol = :Max_Distance</code>: the method used to model the problem for generating alternatives.</li><li><code>metric::Distances.Metric=SqEuclidean()</code>: the metric used to maximise the difference between alternatives and the optimal solution.</li><li><code>fixed_variables::Vector{VariableRef}=[]</code>: a subset of all variables of <code>model</code> that are not allowed to be changed when seeking for alternatives.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/generate-alternatives.jl#L3-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.is_better_psoga-Union{Tuple{T}, Tuple{T, T, Matrix{Float64}, Int64, Bool}} where T&lt;:Metaheuristics.xFgh_solution"><a class="docstring-binding" href="#NearOptimalAlternatives.is_better_psoga-Union{Tuple{T}, Tuple{T, T, Matrix{Float64}, Int64, Bool}} where T&lt;:Metaheuristics.xFgh_solution"><code>NearOptimalAlternatives.is_better_psoga</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>is<em>better</em>psoga(     A::T,     B::T,     centroids::Vector{Any},     subpop<em>a::Int64,     subpop</em>b::Int64,     maximise<em>total::Bool   ) where {T &lt;: Metaheuristics.xFgh</em>solution}</p><p>Compare two solutions of the PSOGA algorithm with respect to their distance to the optimal solution and other alternatives.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: solution in PSOGA to be compared.</li><li><code>B</code>: solution in PSOGA to be compared.</li><li><code>centroids::Vector{Any}</code>: vector of centroids per subpopulation. A centroid is the average point of all solutions in a subpopulation.</li><li><code>subpop::Int64</code>: index of the subpopulation solution A and B are in. Note that they are always in the same, since we only compare within subpopulations or with themselves.</li><li><code>maximise_total::Bool</code>: if true, we maximise the sum of distances between a point and all centroids of other subpopulations, else we maximise the minimum distance between a point and the centroids of other subpopulations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/algorithms/PSOGA/is_better.jl#L1-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.run_alternative_generating_problem!-Tuple{NearOptimalAlternatives.MetaheuristicProblem}"><a class="docstring-binding" href="#NearOptimalAlternatives.run_alternative_generating_problem!-Tuple{NearOptimalAlternatives.MetaheuristicProblem}"><code>NearOptimalAlternatives.run_alternative_generating_problem!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">result = run_alternative_generating_problem!(
    problem::MetaheuristicProblem
)</code></pre><p>Optimize the <code>problem</code> using the specified metaheuristic algorithm and return the result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/alternative-metaheuristics.jl#L332-L338">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.update_objective_function!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><a class="docstring-binding" href="#NearOptimalAlternatives.update_objective_function!-Union{Tuple{N}, Tuple{T}, Tuple{JuMP.Model, AbstractArray{T, N}}} where {T&lt;:Union{JuMP.VariableRef, JuMP.AffExpr}, N}"><code>NearOptimalAlternatives.update_objective_function!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update_objective_function!(
    model::JuMP.Model,
    variables::AbstractArray{T,N};
    weights::Vector{Float64} = zeros(length(variables)),
    method::Symbol = :HSJ,
    metric::Distances.SemiMetric = SqEuclidean()) where {T&lt;:Union{VariableRef,AffExpr},N}
)</code></pre><p>Add a previously found solution to a modelling-for-generating-alternatives problem. Used for iteratively finding multiple alternative solutions.</p><p><strong>Arguments</strong></p><ul><li><code>model::JuMP.Model</code>: a solved JuMP model for which alternatives are generated.</li><li><code>variables::AbstractArray{T,N}</code>: the variables of <code>model</code> for which are considered when generating alternatives.</li><li><code>weights::Vector{Float64}</code>: a vector of weights used to update the objective function.</li><li><code>method::Symbol = :HSJ</code>: the method used to model the problem for generating alternatives.</li><li><code>metric::Distances.SemiMetric = SqEuclidean()</code>: the metric used to maximise the difference between alternatives and the optimal solution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/alternative-optimization.jl#L87-L105">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.update_solutions!-Tuple{NearOptimalAlternatives.AlternativeSolutions, JuMP.Model}"><a class="docstring-binding" href="#NearOptimalAlternatives.update_solutions!-Tuple{NearOptimalAlternatives.AlternativeSolutions, JuMP.Model}"><code>NearOptimalAlternatives.update_solutions!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update_solutions!(results::AlternativeSolutions, model::JuMP.Model)</code></pre><p>Update the set of results <code>AlternativeSolutions</code> with the variable values obtained when solving the JuMP model <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/results.jl#L9-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.update_solutions!-Tuple{NearOptimalAlternatives.AlternativeSolutions, Metaheuristics.State, OrderedCollections.OrderedDict{JuMP.VariableRef, Float64}, Dict{MathOptInterface.VariableIndex, Float64}, JuMP.Model}"><a class="docstring-binding" href="#NearOptimalAlternatives.update_solutions!-Tuple{NearOptimalAlternatives.AlternativeSolutions, Metaheuristics.State, OrderedCollections.OrderedDict{JuMP.VariableRef, Float64}, Dict{MathOptInterface.VariableIndex, Float64}, JuMP.Model}"><code>NearOptimalAlternatives.update_solutions!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update_solutions!(results::AlternativeSolutions, model::JuMP.Model)</code></pre><p>Update the set of results <code>AlternativeSolutions</code> with the variable values obtained when solving using Metaheuristics.</p><p><strong>Arguments</strong></p><ul><li><code>results::AlternativeSolutions</code>: set of solutions to add a new solution to.</li><li><code>state::Metaheuristics.State</code>: contains results to metaheuristic solve.</li><li><code>initial:solution::OrderedDict{VariableRef, Float64}</code>: used to identify the indices of the metaheuristic solution in the JuMP model.</li><li><code>fixed_variables::Dict{MOI.VariableIndex, Float64}</code>: set of fixed variables and their solution values.</li><li><code>model::JuMP.Model</code>: original model for which alternative solutions are found.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/results.jl#L38-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NearOptimalAlternatives.update_solutions!-Tuple{NearOptimalAlternatives.AlternativeSolutions, Metaheuristics.State, Vector{Any}, OrderedCollections.OrderedDict{JuMP.VariableRef, Float64}, Dict{MathOptInterface.VariableIndex, Float64}, JuMP.Model}"><a class="docstring-binding" href="#NearOptimalAlternatives.update_solutions!-Tuple{NearOptimalAlternatives.AlternativeSolutions, Metaheuristics.State, Vector{Any}, OrderedCollections.OrderedDict{JuMP.VariableRef, Float64}, Dict{MathOptInterface.VariableIndex, Float64}, JuMP.Model}"><code>NearOptimalAlternatives.update_solutions!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update_solutions!(results::AlternativeSolutions, model::JuMP.Model)</code></pre><p>Update the set of results <code>AlternativeSolutions</code> with the variable values obtained when solving using PSOGA.</p><p><strong>Arguments</strong></p><ul><li><code>results::AlternativeSolutions</code>: set of solutions to add a new solution to.</li><li><code>state::Metaheuristics.State</code>: contains results to metaheuristic solve.</li><li><code>subBest::Vector{Any}</code>: contains the best results per subpopulation of PSOGA, which are the actual results of solving.</li><li><code>initial:solution::OrderedDict{VariableRef, Float64}</code>: used to identify the indices of the metaheuristic solution in the JuMP model.</li><li><code>fixed_variables::Dict{MOI.VariableIndex, Float64}</code>: set of fixed variables and their solution values.</li><li><code>model::JuMP.Model</code>: original model for which alternative solutions are found.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/3ceb20253c0b02b8363115b9a003ad6a9ecb95c3/src/results.jl#L91-L103">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../91-developer/">« Developer documentation</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 4 February 2026 15:52">Wednesday 4 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
