<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Concepts · NearOptimalAlternatives.jl</title><meta name="title" content="Concepts · NearOptimalAlternatives.jl"/><meta property="og:title" content="Concepts · NearOptimalAlternatives.jl"/><meta property="twitter:title" content="Concepts · NearOptimalAlternatives.jl"/><meta name="description" content="Documentation for NearOptimalAlternatives.jl."/><meta property="og:description" content="Documentation for NearOptimalAlternatives.jl."/><meta property="twitter:description" content="Documentation for NearOptimalAlternatives.jl."/><meta property="og:url" content="https://TulipaEnergy.github.io/NearOptimalAlternatives.jl/30-concepts/"/><meta property="twitter:url" content="https://TulipaEnergy.github.io/NearOptimalAlternatives.jl/30-concepts/"/><link rel="canonical" href="https://TulipaEnergy.github.io/NearOptimalAlternatives.jl/30-concepts/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NearOptimalAlternatives.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Welcome</a></li><li><a class="tocitem" href="../10-how-to-use/">How to use</a></li><li><a class="tocitem" href="../20-tutorials/">Tutorials</a></li><li class="is-active"><a class="tocitem" href>Concepts</a><ul class="internal"><li><a class="tocitem" href="#Optimization-based-Methods"><span>Optimization-based Methods</span></a></li><li><a class="tocitem" href="#Evolutionary-Methods"><span>Evolutionary Methods</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../90-contributing/">Contributing guidelines</a></li><li><a class="tocitem" href="../91-developer/">Developer documentation</a></li><li><a class="tocitem" href="../95-reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Concepts</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Concepts</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/TulipaEnergy/NearOptimalAlternatives.jl/blob/main/docs/src/30-concepts.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul></ul><h1 id="Concepts"><a class="docs-heading-anchor" href="#Concepts">Concepts</a><a id="Concepts-1"></a><a class="docs-heading-anchor-permalink" href="#Concepts" title="Permalink"></a></h1><p>Here we explain in more detail the underlying theoretical concepts of NearOptimalAlternatives.jl. We first discuss the optimization-based approaches and then discuss the evolutionary approaches.</p><h2 id="Optimization-based-Methods"><a class="docs-heading-anchor" href="#Optimization-based-Methods">Optimization-based Methods</a><a id="Optimization-based-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-based-Methods" title="Permalink"></a></h2><p>One can directly maximize the distance among the alternatives or minimized the weighted sum of decision variables using a variety of methods listed below.</p><h3 id="Max-Distance-(:Max_Distance)"><a class="docs-heading-anchor" href="#Max-Distance-(:Max_Distance)">Max-Distance (<code>:Max_Distance</code>)</a><a id="Max-Distance-(:Max_Distance)-1"></a><a class="docs-heading-anchor-permalink" href="#Max-Distance-(:Max_Distance)" title="Permalink"></a></h3><ul><li>Files: <code>MGA-Methods/Max-Distance.jl</code></li><li>Goal: maximize distance between the current solution and the reference solution using a chosen metric (default: squared Euclidean; updates default to Cityblock).</li><li>Behavior: <code>Dist_initial!</code> fixes specified variables, captures the current solution, and sets a distance-maximizing objective. <code>Dist_update!</code> adds additional distance terms to encourage further diversity across iterations.</li></ul><p>Given the optimal solution <span>$x^*$</span>, we solve the following problem for any distance metric <span>$d$</span>.</p><p class="math-container">\[\text{Maximize} || x - x^* ||_d \\\]</p><h3 id="Hop-Skip-Jump-(:HSJ)"><a class="docs-heading-anchor" href="#Hop-Skip-Jump-(:HSJ)">Hop-Skip-Jump (<code>:HSJ</code>)</a><a id="Hop-Skip-Jump-(:HSJ)-1"></a><a class="docs-heading-anchor-permalink" href="#Hop-Skip-Jump-(:HSJ)" title="Permalink"></a></h3><ul><li>Files: <code>MGA-Methods/HSJ.jl</code></li><li>Goal: minimize a weighted sum where weights are 1 for nonzero variables and 0 otherwise, biasing the search away from the current support.</li><li>Behavior: <code>HSJ_initial!</code> fixes requested variables and sets weights from the current solution; <code>HSJ_update!</code> recomputes weights from the latest solution before re-solving.</li><li>Hop-Skip-Jump (HSJ) <sup class="footnote-reference"><a id="citeref-HSJ1982" href="#footnote-HSJ1982" class="footnote-ref">[HSJ1982]</a><span class="footnote-preview" id="fn-HSJ1982"></span></sup> is a method that tries to find alternatives by minimizing the variables that had a non-zero value in the previous iteration. This is done to find alternatives that invest less in the decision variable, which was already invested in in the previous iteration. More precisely, it minimizes based on the value of the variables in the previous iteration.</li></ul><p>The objective is to minimize the weighted sum of decision variables <span>$x_i$</span> using weights <span>$w_i^{k}$</span> where <span>$i$</span> is the index of variables and <span>$k$</span> is the index of iterations.</p><p class="math-container">\[w_i^{k} = \begin{cases}
0, &amp; \text{if } x_i^{k-1} = 0 \\
1, &amp; \text{otherwise.}
\end{cases}\]</p><h3 id="Spores-(:Spores)"><a class="docs-heading-anchor" href="#Spores-(:Spores)">Spores (<code>:Spores</code>)</a><a id="Spores-(:Spores)-1"></a><a class="docs-heading-anchor-permalink" href="#Spores-(:Spores)" title="Permalink"></a></h3><ul><li>Files: <code>MGA-Methods/Spores.jl</code></li><li>Goal: shift emphasis toward variables that could take larger values relative to their upper bounds (upper bounds required for all variables involved).</li><li>Behavior: <code>Spores_initial!</code> and <code>Spores_update!</code> accumulate weights as <code>weights[i] += value(v) / upper_bound(v)</code> and minimize the resulting weighted sum.</li><li>Spores <sup class="footnote-reference"><a id="citeref-SPORES2020" href="#footnote-SPORES2020" class="footnote-ref">[SPORES2020]</a><span class="footnote-preview" id="fn-SPORES2020"></span></sup> is a modification of HSJ. It does not discard the weights of the previous iteration. Instead, it updates them using the update rule as described below. This equation introduces <span>$x^{max}_i$</span> , which refers to the maximum possible value that <span>$x_i$</span> can take. This update rule assigns a high weight to variables whose value is close to the maximum value, while assigning a low weight to variables whose value is close to zero. This is similar to the HSJ method, but with the ability to be more expressive.</li></ul><p>The objective is to minimize the weighted sum of decision variables <span>$x_i$</span> using weights <span>$w_i^{k}$</span> where <span>$i$</span> is the index of variables and <span>$k$</span> is the index of iterations.</p><p class="math-container">\[w_i^k = w_i^{k-1} + \frac{x_i^{k-1}}{x_i^{\text{max}}}, \quad \forall k, 1 \leq k \leq n,\]</p><p class="math-container">\[w_i^0 = 0.\]</p><h3 id="Min/Max-Variables-(:Min_Max_Variables)"><a class="docs-heading-anchor" href="#Min/Max-Variables-(:Min_Max_Variables)">Min/Max Variables (<code>:Min_Max_Variables</code>)</a><a id="Min/Max-Variables-(:Min_Max_Variables)-1"></a><a class="docs-heading-anchor-permalink" href="#Min/Max-Variables-(:Min_Max_Variables)" title="Permalink"></a></h3><ul><li>Files: <code>MGA-Methods/Min-Max-Variables.jl</code></li><li>Goal: randomly push variables to be minimized, maximized, or ignored to explore diverse corners of the feasible region.</li><li>Behavior: both <code>*_initial!</code> and <code>*_update!</code> draw weights uniformly from <code>{-1, 0, 1}</code> and minimize the weighted sum.</li><li>Min/Max Variables <sup class="footnote-reference"><a id="citeref-Evelina2012" href="#footnote-Evelina2012" class="footnote-ref">[Evelina2012]</a><span class="footnote-preview" id="fn-Evelina2012"></span></sup><sup class="footnote-reference"><a id="citeref-Lukas2019" href="#footnote-Lukas2019" class="footnote-ref">[Lukas2019]</a><span class="footnote-preview" id="fn-Lukas2019"></span></sup> is an approach that minimizes and/or maximizes a random sample of variables. This is done by randomly sampling the weights as specified below. Contrary to HSJ and Spores, the Min/Max Variables does not consider any previously found alternatives. When applying this approach, all variables with weight 1 get minimized, the variable with weight −1 gets maximized, and the variables with weight 0 are free.</li></ul><p>The objective is to minimize the weighted sum of decision variables <span>$x_i$</span> using weights <span>$w_i^{k}$</span> where <span>$i$</span> is the index of variables and <span>$k$</span> is the index of iterations.</p><p class="math-container">\[w_i \sim \text{Uniform}(\{−1, 0, 1\}), \forall i\]</p><h3 id="Random-Vector-(:Random_Vector)"><a class="docs-heading-anchor" href="#Random-Vector-(:Random_Vector)">Random Vector (<code>:Random_Vector</code>)</a><a id="Random-Vector-(:Random_Vector)-1"></a><a class="docs-heading-anchor-permalink" href="#Random-Vector-(:Random_Vector)" title="Permalink"></a></h3><ul><li>Files: <code>MGA-Methods/Random-Vector.jl</code></li><li>Goal: similar to Min/Max Variables but with continuous random weights in [-1, 1] for smoother perturbations.</li><li>Behavior: each call redraws weights from <code>Uniform(-1, 1)</code> and minimizes the weighted sum.</li><li>Random Vector <sup class="footnote-reference"><a id="citeref-RANDV2017" href="#footnote-RANDV2017" class="footnote-ref">[RANDV2017]</a><span class="footnote-preview" id="fn-RANDV2017"></span></sup> is similar to Min/Max Variables. Where Min/Max Variables samples either −1, 0, or 1, Random Vector samples a predefined distribution for all variables, most of the time this distribution is the uniform distribution between −1 and 1, as described below. However, the distribution can be different for each variable to best fit the model being solved.</li></ul><p>The objective is to minimize the weighted sum of decision variables <span>$x_i$</span> using weights <span>$w_i^{k}$</span> where <span>$i$</span> is the index of variables and <span>$k$</span> is the index of iterations.</p><p class="math-container">\[w_i \sim \text{Uniform}(−1, 1), \forall i\]</p><h3 id="Directionally-Weighted-Variables-(:Directionally_Weighted_Variables)"><a class="docs-heading-anchor" href="#Directionally-Weighted-Variables-(:Directionally_Weighted_Variables)">Directionally Weighted Variables (<code>:Directionally_Weighted_Variables</code>)</a><a id="Directionally-Weighted-Variables-(:Directionally_Weighted_Variables)-1"></a><a class="docs-heading-anchor-permalink" href="#Directionally-Weighted-Variables-(:Directionally_Weighted_Variables)" title="Permalink"></a></h3><ul><li>Files: <code>MGA-Methods/Directionally-Weighted-Variables.jl</code></li><li>Goal: choose variable directions based on the sign of their coefficients in the original objective to promote directional diversity. This helps to find non-dominated solutions. For the concept of dominance, check out <sup class="footnote-reference"><a id="citeref-VandeLaar2025" href="#footnote-VandeLaar2025" class="footnote-ref">[VandeLaar2025]</a><span class="footnote-preview" id="fn-VandeLaar2025"></span></sup>.</li><li>Behavior: weights depend on objective coefficients (<code>&gt;0</code> draws from {0,1}, <code>&lt;0</code> from {-1,0}, else {-1,0,1}); <code>DWV_initial!</code> fixes requested variables, sets the weighted-sum objective, and <code>DWV_update!</code> redraws weights before the next solve.</li></ul><h2 id="Evolutionary-Methods"><a class="docs-heading-anchor" href="#Evolutionary-Methods">Evolutionary Methods</a><a id="Evolutionary-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Evolutionary-Methods" title="Permalink"></a></h2><p>Evolutionary algorithms have been proposed as an alternative method to mathematical programming for generating alternative solutions by Zechman and Ranjithan <sup class="footnote-reference"><a id="citeref-Zechman" href="#footnote-Zechman" class="footnote-ref">[Zechman]</a><span class="footnote-preview" id="fn-Zechman"></span></sup>.</p><p>Their method works as follows. Instead of simply initializing an initial population as a regular evolutionary algorithm would do, they divide this population into <span>$P$</span> subpopulations, where <span>$P$</span> is equal to the number of alternative solutions to be found. Each subpopulation is dedicated to search for one alternative solution. The first subpopulation can also be used to find the global optimum. After initializing the population, they take the following steps iteratively. First, evaluate all individuals with respect to the objective and feasibility. Also, the distance between this solution and other subpopulations, or there centroids, is taken into account. So, the best individual is a feasible solution which is furthest away from other subpopulations. They used elitism to preserve the best solution in each subpopulation. Afterwards, after checking stopping criteria, they applied binary tournament selection based on the fitness of the solution to select the rest of the individuals.</p><h3 id="Particle-Swarm-Optimization-for-Generating-Alternatives-(PSOGA)"><a class="docs-heading-anchor" href="#Particle-Swarm-Optimization-for-Generating-Alternatives-(PSOGA)">Particle Swarm Optimization for Generating Alternatives (PSOGA)</a><a id="Particle-Swarm-Optimization-for-Generating-Alternatives-(PSOGA)-1"></a><a class="docs-heading-anchor-permalink" href="#Particle-Swarm-Optimization-for-Generating-Alternatives-(PSOGA)" title="Permalink"></a></h3><p>In this package we developed PSOGA, an modification of Evolutionary Algorithms for Generating Alternatives using Particle Swarm Optimization (PSO).</p><ul><li>Files: <code>algorithms/PSOGA/PSOGA.jl</code> and <code>algorithms/PSOGA/is_better.jl</code>.</li><li>Goal: maximize distance from provided solution within search space</li><li>Behavior: <code>initialize!</code> initializez population and global parameters. <code>update_state!</code> performs one loop of he metaheuristic process. <code>final_stage!</code> performs final steps after solving the problem.</li></ul><p>It works as follows.</p><p>When initializing the algorithm, the population of individuals is divided into <span>$n$</span> equal-size subpopulations, where <span>$n$</span> is the number of alternative solutions sought. As with regular PSO, each individual has a position <span>$x$</span> and a velocity <span>$v$</span>.</p><p>The update step of the algorithm works very similar to regular PSO. In every iteration, each individual is updated as follows. First, its velocity is updated and becomes <span>$v = \omega \cdot v + \textit{rand}(0,1) \cdot c_1 \cdot (p_{\textit{best}} - x)  + \textit{rand}(0,1) \cdot c_2 \cdot (s_{\textit{best}} - x).$</span> In the above equation, <span>$\omega$</span> represents the inertia, <span>$c_1$</span> is the cognitive parameter and <span>$c_2$</span> is the social parameter. These make sure that the old velocity is taken into account, previous information from this individual is used and information from other individuals in the subpopulation is used, respectively. Therefore, the variables <span>$p_\textit{best}$</span>, representing the personal best position of this individual, and <span>$s_\textit{best}$</span>,representing the alltime best of the subpopulation this individual is in, are required. Note that <span>$s_\textit{best}$</span> replaces <span>$g_\textit{best}$</span>, which is used in regular PSO and represents the global best solution of the full population.</p><p>After updating the velocity of each individual, all positions are updated using <span>$x = x + v$</span>. Subsequently, all personal bests and subpopulation bests are updated based on the objective value. For PSOGA the objective is to generate alternatives that are as different as possible from the optimal solution, but also from each other. The aim here is to make sure each subpopulation finds one alternative, and these are spread out over the search space.</p><p>When comparing two solutions to decide which is better, we therefore take the following approach. If either of the solutions is infeasible, we take the solution with the smallest constraint violation. If none are infeasible we pick the one with the largest distance, where the distance can be defined in two ways. Either, we calculate the sum of all distances to other subpopulations and to the original optimal solution, or we calculate the minimum of the distances to other subpopulations and the original optimal solution. To compute the distance to other subpopulations, we calculate the centroid (average) of all points in the subpopulation and compute the distance to that centroid.</p><p>The algorithm terminates when the subpopulations have converged, or the maximum number of iterations has been met. By then, the subpopulations should be spread out over the feasible space and as far as possible from the initial optimal solution.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Evelina2012"><a class="tag is-link" href="#citeref-Evelina2012">Evelina2012</a>Evelina Trutnevyte et al. “Context-specific energy strategies: coupling energy system visions with feasible implementation scenarios”. In: Environmental science &amp; technology 46.17 (2012), pp. 9240–9248</li><li class="footnote" id="footnote-HSJ1982"><a class="tag is-link" href="#citeref-HSJ1982">HSJ1982</a>E Downey Brill Jr, Shoou-Yuh Chang, and Lewis D Hopkins. “Modeling to generate alternatives: The HSJ approach and an illustration using a problem in land use planning”. In: Management Science 28.3 (1982), pp. 221–235.</li><li class="footnote" id="footnote-Lukas2019"><a class="tag is-link" href="#citeref-Lukas2019">Lukas2019</a>Lukas Nacken et al. “Integrated renewable energy systems for Germany–A model-based exploration of the decision space”. In: 2019 16th international conference on the European energy market (EEM). IEEE. 2019, pp. 1–8.</li><li class="footnote" id="footnote-RANDV2017"><a class="tag is-link" href="#citeref-RANDV2017">RANDV2017</a>Philip B Berntsen and Evelina Trutnevyte. “Ensuring diversity of national energy scenarios: Bottomup energy system model with Modeling to Generate Alternatives”. In: Energy 126 (2017), pp. 886–898.</li><li class="footnote" id="footnote-SPORES2020"><a class="tag is-link" href="#citeref-SPORES2020">SPORES2020</a>Francesco Lombardi et al. “Policy decision support for renewables deployment through spatially explicit practically optimal alternatives”. In: Joule 4.10 (2020), pp. 2185–2207.</li><li class="footnote" id="footnote-VandeLaar2025"><a class="tag is-link" href="#citeref-VandeLaar2025">VandeLaar2025</a>Luuk van de Laar. &quot;Dominance-Aware Generation of Near-Optimal Alternatives in Energy System Models&quot;, TU Delft thesis, 2025</li><li class="footnote" id="footnote-Zechman"><a class="tag is-link" href="#citeref-Zechman">Zechman</a>E. M. Zechman and S. R. Ranjithan, “An evolutionary algorithm to generate alternatives (eaga) for engineering optimization problems,” Engineering Optimization, vol. 36, no. 5, pp. 539–553, 2004.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../20-tutorials/">« Tutorials</a><a class="docs-footer-nextpage" href="../90-contributing/">Contributing guidelines »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 4 February 2026 11:05">Wednesday 4 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
